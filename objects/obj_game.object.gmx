<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var i = 0;

STATE_MAIN = i++;
STATE_MOVE = i++;
STATE_MOVE_RANGE = i++;

state = STATE_MAIN;
state_timer = 0;
next_state = state;

selected_unit = noone;
selected_tile = noone;

movement_grid=mp_grid_create(-8, -8, room_width/16, room_height/16, 16, 16);
movement_path=path_add();
mp_grid_clear_all(movement_grid);
mp_grid_add_instances(movement_grid, obj_wall, false);
mp_grid_add_instances(movement_grid, obj_unit, false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// State: Main
///
/// The Main State is where we chose which unit is going to move.
/// Clicking a unit selects it in the variable selected_unit
/// And then we switch states to the Move Range state.


if (state == STATE_MAIN)
{
    if (state_timer == 0)
    {
        // reset variables
        selected_unit = noone;
        selected_tile = noone;
        selected_wall = noone;
        
        // reset floor tiles
        with(obj_floor)
        {
            Reachable = false;
            Half_Turn = false;
            Full_Turn = false;
        }
        // reset unit tiles
        with(obj_unit)
        {
            Selected_unit = false;
        }
    }
    
    if (mouse_check_button_pressed(mb_left))
    {
        // This code selects a unit to be moved.
        // Code can be added to see, for instance, if 
        // the unit's team is a selectable team
           
        selected_unit = instance_position(obj_mouse.x, obj_mouse.y, obj_unit);
        
        // switch over to the move range state
        if(selected_unit)
        {
            state_switch(STATE_MOVE_RANGE);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// State: Move Range

if (state == STATE_MOVE_RANGE)
{
    if (state_timer == 0)
    {
        // First, we need to find where the unit can move to
        // The unit's tile is kept in a variable called my_tile
        // and its move range is MoveRange. Move range can be adjusted.
        // What this script does is mark all reachable tiles with a
        // variable called Reachable stored in the floor tile. The tile
        // then changes color to reflect a Reachable state. Check out the
        // floor object Draw Event to see how it changes and to be able to
        // alter it.
            
        if(selected_unit.Turns &gt; 0)
        {
            FindMovementRange(selected_unit.my_tile, selected_unit.MoveRange, selected_unit.Turns);
        }
        
        // Make sure that the unit can't move to a tile with a unit on it.
        with(obj_unit)
        {
            my_tile.Reachable = false;
            my_tile.Cost = 1;
        }
        
        // Highlight selected unit
        with(selected_unit)
        {
            Selected_unit = true;
        }
    }
    
    if mouse_check_button_pressed(mb_left)
    {
        // The first bit of this code just checks to see if the mouse has
        // selected a unit. If so, cancel the movement and switch to the main state
        // otherwise, check to see if there's a tile under the mouse and
        // store that variable in selected_tile and switch to the move state.
        
        if(instance_position(mouse_x, mouse_y, obj_unit))
        {
            state_switch(STATE_MAIN);
        }
        else if(instance_position(mouse_x, mouse_y, obj_wall))
        {
           state_switch(STATE_MAIN);
        }
        else
        {
            selected_tile = instance_position(mouse_x, mouse_y, obj_floor);
      
            if(selected_tile &amp;&amp; selected_tile.Reachable)
            {
                selected_unit.Turns -= 1;
                state_switch(STATE_MOVE);
            }
            else
            {
                state_switch(STATE_MAIN);
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// State: Move

if(state == STATE_MOVE)
{
    // The move state simply uses mp_grid to move the unit to the
    // selected tile's x and y coords. Pretty straight forward.
    
    if(state_timer == 0)
    {
        mp_grid_clear_all(movement_grid);
        // idIndex of the mp_grid that is to be used
        // objObject index, or instance id, of the instances to be added into the mp_grid
        // precWhether the check is based on pixel-perfect collisions (true = slow) or its bounding box in general (false = fast).
        mp_grid_add_instances(movement_grid, obj_wall, false);
        
        with(obj_floor)
        {
            Reachable = false;
        }
    }

    with(selected_unit)
    {   
        Selected_unit = true;
        x=floor(x);
        y=floor(y);
        mp_grid_path(other.movement_grid, other.movement_path, x, y, other.selected_tile.x, other.selected_tile.y, false)
        path_start(other.movement_path, 8, 0, 1);
    }

    if(selected_unit.x==selected_tile.x and selected_unit.y==selected_tile.y)
    {
        state_switch(STATE_MAIN);
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle States
///
/// Switches states when need be and also sets the my_tile and my_unit
/// variables for the floor and the units.

if(next_state != state)
{
    state = next_state;
}
else
{
    state_timer++;
}
    
with(obj_unit)
{
    my_tile = instance_position(x, y, obj_floor);
}
    
with(obj_floor)
{
    my_unit = instance_position(x, y, obj_unit);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
